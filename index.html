<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D DEM Explorer V4.5 (GeoTIFF Export)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100%; height: 100vh; display: block; touch-action: none; }
        
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 12px;
            max-width: 280px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.15);
            transition: opacity 0.3s, transform 0.3s;
            max-height: 85vh;
            overflow-y: auto;
            z-index: 20;
        }

        #minimap-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        #minimap-title {
            color: #4a90e2;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 5px;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }

        #minimap-wrapper {
            position: relative;
            display: inline-block; 
            border: 1px solid #444;
            background: #000;
            line-height: 0;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #minimap-img {
            display: block;
            max-width: 180px; 
            max-height: 250px;
            height: auto;
            width: auto;
            image-rendering: pixelated; 
        }

        #minimap-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff3333;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            box-shadow: 0 0 4px rgba(0,0,0,0.8);
            z-index: 10;
            pointer-events: none;
        }
        #minimap-marker::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 100%; height: 100%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.5);
        }

        #elevation-display {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #4a90e2;
            font-weight: bold;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
            width: 100%;
            text-align: center;
            box-sizing: border-box;
        }

        #loading-indicator {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 25px;
            border-radius: 12px;
            z-index: 50;
            display: none;
            text-align: center;
            border: 1px solid #4a90e2;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #toggle-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 25;
            background: rgba(0,0,0,0.5);
            border: 1px solid white;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px; color: #4a90e2; }
        
        .control-group { margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 4px; font-size: 0.75rem; font-weight: bold; color: #aaa; }
        
        input[type="file"] { display: none; }

        .btn {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            width: 100%;
            display: block;
            box-sizing: border-box;
            text-align: center;
            font-weight: 600;
            transition: background 0.2s;
        }
        .btn:hover { background: #357abd; }
        .btn-secondary { background: #444; margin-top: 5px;}
        .btn-secondary:hover { background: #555; }
        .btn-green { background: #28a745; margin-top: 5px; }
        .btn-green:hover { background: #218838; }
        .btn-orange { background: #fd7e14; margin-top: 5px; }
        .btn-orange:hover { background: #e36d0d; }
        .btn-outline { background: transparent; border: 1px solid #4a90e2; color: #4a90e2; margin-top: 5px; }
        .btn-outline:hover { background: rgba(74, 144, 226, 0.1); }
        
        select, input[type="range"] {
            width: 100%;
            background: #222;
            color: white;
            border: 1px solid #444;
            padding: 5px;
            border-radius: 4px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            color: #fff;
            margin-top: 5px;
        }
        .checkbox-label input {
            width: auto;
            margin-right: 10px;
        }

        #blocker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
            backdrop-filter: blur(3px);
        }
        #instructions {
            color: white;
            text-align: center;
            cursor: pointer;
            padding: 20px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            background: rgba(0,0,0,0.5);
        }
        #instructions h2 { margin: 0 0 10px 0; }
        .mobile-hint { font-size: 0.8rem; color: #ffd700; margin-top: 10px; display: none; }

        .touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none;
            z-index: 15;
            display: none;
        }

        #joystick-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255,255,255,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #jump-btn {
            position: absolute;
            bottom: 40px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: rgba(74, 144, 226, 0.4);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            user-select: none;
        }
        #jump-btn:active { background: rgba(74, 144, 226, 0.8); }

        @media (max-width: 600px) {
            #minimap-container { width: 120px; top: 60px; right: 10px; }
            #toggle-ui { display: flex; }
            #ui-layer { display: none; top: 60px; }
        }

        #stat-display {
            font-size: 0.7rem; color: #888; margin-top: 5px; font-family: monospace;
        }
    </style>
</head>
<body>

<div id="toggle-ui">‚öôÔ∏è</div>

<div id="loading-indicator">
    <div style="margin-bottom: 10px; font-size: 1.2em;">Processing DEM data...</div>
    <div id="loading-msg" style="font-size: 0.9em; color: #ccc;">Adjusting scale & memory...</div>
</div>

<div id="minimap-container">
    <div id="minimap-title">Random World</div>
    <div id="minimap-wrapper">
        <img id="minimap-img" src="" alt="DEM Preview">
        <div id="minimap-marker"></div>
    </div>
    <div id="elevation-display">Elev: ---</div>
</div>

<div id="ui-layer">
    <h1>Terrain Engine V4.5</h1>
    
    <div class="control-group">
        <label>1. Detail Level</label>
        <select id="resolution-selector">
            <option value="128">Low (Fast)</option>
            <option value="256" selected>Medium</option>
            <option value="512">High</option>
            <option value="1024">Ultra (1M Polys)</option>
            <option value="2048">Hyper (4M Polys)</option>
            <option value="4096">Extreme (16M Polys)</option>
        </select>
        <div id="stat-display">Res: 256x256</div>
    </div>

    <div class="control-group">
        <label>2. Source</label>
        <label for="heightmap-upload" class="btn">üìÇ Upload GeoTIFF / Img</label>
        <input type="file" id="heightmap-upload" accept=".tif, .tiff, image/png, image/jpeg, image/webp">
        <button id="btn-random" class="btn btn-secondary">üé≤ Generate Geo-World</button>
    </div>

    <div class="control-group">
        <label>3. Rendering</label>
        <label>Color Style</label>
        <select id="texture-style">
            <option value="nature" selected>Nature (Snow/Rock/Grass)</option>
            <option value="scientific">Scientific (Atlas Colors)</option>
            <option value="grayscale">Grayscale (Raw Height)</option>
            <option value="clay">Clay (Neutral)</option>
        </select>

        <label class="checkbox-label">
            <input type="checkbox" id="btn-smooth" checked> Smooth Terrain
        </label>
        
        <label style="margin-top:10px">Vertical Exaggeration</label>
        <input type="range" id="height-scale" min="1" max="1000" value="150">
        <button id="btn-realistic" class="btn btn-outline" title="Use file metadata to set 1:1 scale">üìè Set Realistic (1:1) Scale</button>
    </div>

    <div class="control-group">
        <label>4. Exports</label>
        <button id="btn-export" class="btn btn-green">üíæ 3D Model (.glb)</button>
        <button id="btn-export-dem" class="btn btn-orange" style="display:none">üó∫Ô∏è Export GeoTIFF</button>
    </div>
</div>

<div id="blocker">
    <div id="instructions">
        <h2>Click to Start</h2>
        <p>Desktop: WASD to Move, Mouse to Look</p>
        <p class="mobile-hint">Mobile: Left Joystick Move, Right Side Look</p>
    </div>
</div>

<div class="touch-controls" id="touch-ui">
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="jump-btn">JUMP</div>
</div>

<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "geotiff": "https://cdn.jsdelivr.net/npm/geotiff@2.1.3/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
    import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
    import { fromBlob } from 'geotiff';

    // --- Configuration ---
    const BASE_SIZE = 2000; 
    let currentWorldWidth = BASE_SIZE;
    let currentWorldDepth = BASE_SIZE;
    
    let CHUNK_RES = 256; 
    let HEIGHT_SCALE = 300; 
    
    // --- Globals ---
    let camera, scene, renderer, controls;
    let terrainGroup = null; 
    let waterMesh;
    
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false, isRunning = false;
    
    let prevTime = performance.now();
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    
    let rawHeightData = null; 
    let processedHeightData = null; 
    
    let demMetaData = {
        min: 0, max: 100, rawWidth: 100, rawHeight: 100,
        pixelScaleX: 1, hasMetadata: false
    };

    let activeGeoTiffImage = null; 
    let activeImageSource = null; 
    let isRandomGen = true; 
    
    let isMobile = false;
    let touchLookStartX = 0, touchLookStartY = 0;
    let cameraPitch = 0; 

    let currentAspect = 1.0; 
    
    init();
    animate();

    function init() {
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if(isMobile) {
            document.querySelector('.mobile-hint').style.display = 'block';
            document.getElementById('touch-ui').style.display = 'block';
            document.getElementById('toggle-ui').style.display = 'flex';
        }

        const container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 100, BASE_SIZE * 1.2); 

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000); 
        camera.position.y = 100;

        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(500, 2000, 500);
        scene.add(dirLight);

        renderer = new THREE.WebGLRenderer({ antialias: !isMobile }); 
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        terrainGroup = new THREE.Group();
        scene.add(terrainGroup);

        setupEvents();
        
        generateAdvancedRandomTerrain();
    }

    function setupEvents() {
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        
        instructions.addEventListener('click', () => {
            if(!isMobile) controls.lock();
            else {
                blocker.style.display = 'none';
                document.getElementById('ui-layer').style.display = 'none';
            }
        });

        controls.addEventListener('lock', () => {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
            document.getElementById('ui-layer').style.opacity = '0.3';
        });

        controls.addEventListener('unlock', () => {
            if(!isMobile) {
                blocker.style.display = 'flex';
                instructions.style.display = '';
                document.getElementById('ui-layer').style.opacity = '1';
            }
        });

        document.getElementById('toggle-ui').addEventListener('click', () => {
            const ui = document.getElementById('ui-layer');
            ui.style.display = (ui.style.display === 'none') ? 'block' : 'none';
        });

        document.getElementById('height-scale').addEventListener('input', (e) => {
            HEIGHT_SCALE = parseInt(e.target.value);
            updateTerrainGeometry();
        });

        document.getElementById('btn-smooth').addEventListener('change', () => {
            if(rawHeightData) buildTerrain(rawHeightData, window.terrainW, window.terrainH);
        });

        document.getElementById('texture-style').addEventListener('change', () => {
            if(rawHeightData) buildTerrain(rawHeightData, window.terrainW, window.terrainH);
        });

        document.getElementById('btn-realistic').addEventListener('click', setRealisticScale);

        document.getElementById('resolution-selector').addEventListener('change', (e) => {
            CHUNK_RES = parseInt(e.target.value);
            triggerReload();
        });

        document.getElementById('btn-random').addEventListener('click', () => {
            activeGeoTiffImage = null;
            activeImageSource = null;
            document.getElementById('minimap-title').innerText = "Random World";
            generateAdvancedRandomTerrain();
        });

        document.getElementById('heightmap-upload').addEventListener('change', handleFileUpload);
        
        document.getElementById('btn-export').addEventListener('click', exportGLB);
        document.getElementById('btn-export-dem').addEventListener('click', exportGeoTIFF); 

        document.addEventListener('keydown', (e) => onKey(e, true));
        document.addEventListener('keyup', (e) => onKey(e, false));
        
        if(isMobile) setupTouchControls();
        window.addEventListener('resize', onWindowResize);
    }

    function setRealisticScale() {
        if (!demMetaData.hasMetadata) {
            alert("No GeoTIFF metadata found (or standard image used). Assuming 1px = 1m.");
            demMetaData.pixelScaleX = 1;
        }

        const realWidthMeters = demMetaData.rawWidth * demMetaData.pixelScaleX;
        const realHeightRangeMeters = demMetaData.max - demMetaData.min;

        if (realWidthMeters <= 0) return;

        const ratio = realHeightRangeMeters / realWidthMeters;
        const newScale = currentWorldWidth * ratio;

        HEIGHT_SCALE = newScale;
        document.getElementById('height-scale').value = Math.round(newScale);
        updateTerrainGeometry();
        
        alert(`Scale set to 1:1.\nReal Width: ${(realWidthMeters/1000).toFixed(2)}km\nHeight Range: ${Math.round(realHeightRangeMeters)}m`);
    }

    // --- CORE TERRAIN BUILDER WITH CHUNKING ---

    function buildTerrain(heights, width, height) {
        while(terrainGroup.children.length > 0){ 
            const mesh = terrainGroup.children[0];
            mesh.geometry.dispose();
            if(mesh.material) mesh.material.dispose();
            terrainGroup.remove(mesh);
        }
        if (waterMesh) scene.remove(waterMesh);

        window.terrainW = width;
        window.terrainH = height;

        if (currentAspect >= 1) {
            currentWorldWidth = BASE_SIZE;
            currentWorldDepth = BASE_SIZE / currentAspect;
        } else {
            currentWorldDepth = BASE_SIZE;
            currentWorldWidth = BASE_SIZE * currentAspect;
        }

        const isSmooth = document.getElementById('btn-smooth').checked;
        if (isSmooth) {
             processedHeightData = smoothHeights(heights, width, height);
        } else {
             processedHeightData = new Float32Array(heights);
        }

        const maxChunkVerts = 256;
        const segX = width - 1;
        const segY = height - 1;
        
        const chunksX = Math.ceil(segX / maxChunkVerts);
        const chunksY = Math.ceil(segY / maxChunkVerts);
        
        const style = document.getElementById('texture-style').value;
        const material = new THREE.MeshStandardMaterial({ 
            vertexColors: true, 
            roughness: (style === 'clay') ? 0.6 : 0.8, 
            flatShading: !isSmooth
        });

        for (let y = 0; y < chunksY; y++) {
            for (let x = 0; x < chunksX; x++) {
                
                const startX = x * maxChunkVerts;
                const startY = y * maxChunkVerts;
                
                const currentSegX = Math.min(maxChunkVerts, segX - startX);
                const currentSegY = Math.min(maxChunkVerts, segY - startY);
                
                const chunkWidth = (currentSegX / segX) * currentWorldWidth;
                const chunkDepth = (currentSegY / segY) * currentWorldDepth;
                
                const xOffset = (startX / segX) * currentWorldWidth - (currentWorldWidth / 2) + (chunkWidth / 2);
                const zOffset = (startY / segY) * currentWorldDepth - (currentWorldDepth / 2) + (chunkDepth / 2);

                const geometry = new THREE.PlaneGeometry(chunkWidth, chunkDepth, currentSegX, currentSegY);
                geometry.rotateX(-Math.PI / 2);
                geometry.translate(xOffset, 0, zOffset); 

                const vertices = geometry.attributes.position.array;
                const colors = [];
                const color = new THREE.Color();

                for (let iy = 0; iy <= currentSegY; iy++) {
                    for (let ix = 0; ix <= currentSegX; ix++) {
                        
                        const globalX = startX + ix;
                        const globalY = startY + iy;
                        
                        const safeGX = Math.min(globalX, width - 1);
                        const safeGY = Math.min(globalY, height - 1);
                        
                        const dataIdx = safeGY * width + safeGX;
                        const h = processedHeightData[dataIdx];
                        
                        const localIdx = iy * (currentSegX + 1) + ix;
                        vertices[localIdx * 3 + 1] = h * HEIGHT_SCALE;

                        if (style === 'nature') {
                            if (h < 0.15) color.setHex(0xe3c07f); 
                            else if (h < 0.4) {
                                color.setHex(0x567d46); 
                                color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.05);
                            } else if (h < 0.7) {
                                color.setHex(0x5a5a5a); 
                                color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
                            } else color.setHex(0xffffff); 
                        } else if (style === 'scientific') {
                            if (h < 0.2) color.setHex(0x004400).lerp(new THREE.Color(0x55aa55), h / 0.2); 
                            else if (h < 0.4) color.setHex(0x55aa55).lerp(new THREE.Color(0xd2b48c), (h - 0.2) / 0.2);
                            else if (h < 0.7) color.setHex(0xd2b48c).lerp(new THREE.Color(0x8b4513), (h - 0.4) / 0.3);
                            else if (h < 0.9) color.setHex(0x8b4513).lerp(new THREE.Color(0x444444), (h - 0.7) / 0.2);
                            else color.setHex(0x444444).lerp(new THREE.Color(0xffffff), (h - 0.9) / 0.1);
                        } else if (style === 'grayscale') {
                            color.setScalar(h);
                        } else { 
                            color.setHex(0xaaaaaa);
                        }
                        colors.push(color.r, color.g, color.b);
                    }
                }

                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.computeVertexNormals();
                
                geometry.userData = { startX, startY, segX: currentSegX, segY: currentSegY };

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.frustumCulled = true; 
                
                terrainGroup.add(mesh);
            }
        }

        const waterGeo = new THREE.PlaneGeometry(currentWorldWidth, currentWorldDepth);
        waterGeo.rotateX(-Math.PI / 2);
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x0077be, transparent: true, opacity: 0.6, roughness: 0.1, metalness: 0.5 });
        waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.position.y = HEIGHT_SCALE * 0.12;
        scene.add(waterMesh);

        if(velocity.length() === 0) controls.getObject().position.set(0, HEIGHT_SCALE + 50, 0);
    }

    function updateTerrainGeometry() {
        if(!processedHeightData || terrainGroup.children.length === 0) return;
        
        const width = window.terrainW;
        
        terrainGroup.children.forEach(mesh => {
            const geo = mesh.geometry;
            const { startX, startY, segX, segY } = geo.userData;
            const vertices = geo.attributes.position.array;
            
            for (let iy = 0; iy <= segY; iy++) {
                for (let ix = 0; ix <= segX; ix++) {
                    const globalX = Math.min(startX + ix, width - 1);
                    const globalY = Math.min(startY + iy, window.terrainH - 1);
                    const h = processedHeightData[globalY * width + globalX];
                    
                    const localIdx = iy * (segX + 1) + ix;
                    vertices[localIdx * 3 + 1] = h * HEIGHT_SCALE;
                }
            }
            
            geo.attributes.position.needsUpdate = true;
            geo.computeVertexNormals();
        });

        if(waterMesh) waterMesh.position.y = HEIGHT_SCALE * 0.12;
    }

    function exportGLB() {
        if(terrainGroup.children.length === 0) return;
        const loader = document.getElementById('loading-indicator');
        loader.style.display = 'block';
        document.getElementById('loading-msg').innerText = "Generating 3D Model...";

        setTimeout(() => {
            const exporter = new GLTFExporter();
            const exportList = [terrainGroup];
            if(waterMesh) exportList.push(waterMesh);

            exporter.parse(
                exportList,
                function ( gltf ) {
                    const blob = new Blob( [ gltf ], { type: 'application/octet-stream' } );
                    const link = document.createElement( 'a' );
                    link.style.display = 'none';
                    document.body.appendChild( link );
                    link.href = URL.createObjectURL( blob );
                    link.download = 'terrain_model.glb';
                    link.click();
                    document.body.removeChild( link );
                    loader.style.display = 'none';
                },
                function ( error ) { console.error( error ); alert('Export failed.'); loader.style.display = 'none'; },
                { binary: true }
            );
        }, 100);
    }

    // --- Custom GeoTIFF Writer ---
    function exportGeoTIFF() {
        if(!rawHeightData) return;
        
        const width = window.terrainW;
        const height = window.terrainH;
        const values = new Float32Array(width * height);
        
        const minH = demMetaData.min || 0;
        const maxH = demMetaData.max || 800; 
        const range = maxH - minH;
        
        for(let i=0; i<rawHeightData.length; i++) {
            values[i] = rawHeightData[i] * range + minH;
        }

        const headerSize = 8;
        const ifdEntries = 13;
        const ifdSize = 2 + (ifdEntries * 12) + 4;
        const bitsPerSampleVal = 32;
        const stripByteCountsVal = width * height * 4;
        
        const ifdOffset = headerSize;
        // Fix byte alignment padding
        let dataOffset = ifdOffset + ifdSize;
        const padding = (4 - (dataOffset % 4)) % 4;
        dataOffset += padding;

        const metaValuesSize = 80;
        const valuesOffset = dataOffset + stripByteCountsVal; 
        
        const totalSize = valuesOffset + metaValuesSize;
        const buffer = new ArrayBuffer(totalSize);
        const view = new DataView(buffer);
        
        view.setUint16(0, 0x4949, true); 
        view.setUint16(2, 42, true);     
        view.setUint32(4, ifdOffset, true); 

        let p = ifdOffset;
        view.setUint16(p, ifdEntries, true); p += 2;

        function writeTag(tag, type, count, valueOrOffset) {
            view.setUint16(p, tag, true); p += 2;
            view.setUint16(p, type, true); p += 2;
            view.setUint32(p, count, true); p += 4;
            view.setUint32(p, valueOrOffset, true); p += 4;
        }

        writeTag(256, 3, 1, width);
        writeTag(257, 3, 1, height); 
        writeTag(258, 3, 1, 32); 
        writeTag(259, 3, 1, 1); 
        writeTag(262, 3, 1, 1); 
        writeTag(273, 4, 1, dataOffset);
        writeTag(277, 3, 1, 1); 
        writeTag(278, 3, 1, height); 
        writeTag(279, 4, 1, stripByteCountsVal);
        writeTag(339, 3, 1, 3); 
        
        const scaleOffset = valuesOffset;
        const tieOffset = scaleOffset + 24;
        const geoKeyOffset = tieOffset + 48;
        
        writeTag(33550, 12, 3, scaleOffset); 
        writeTag(33551, 12, 6, tieOffset);   
        writeTag(34735, 3, 4, geoKeyOffset); 

        view.setUint32(p, 0, true); 

        const floatView = new Float32Array(buffer, dataOffset, width * height);
        floatView.set(values);

        view.setFloat64(scaleOffset, 1.0, true);
        view.setFloat64(scaleOffset + 8, 1.0, true);
        view.setFloat64(scaleOffset + 16, 0.0, true);

        for(let i=0; i<6; i++) view.setFloat64(tieOffset + i*8, 0.0, true);

        view.setUint16(geoKeyOffset, 1, true);
        view.setUint16(geoKeyOffset + 2, 1, true);
        view.setUint16(geoKeyOffset + 4, 0, true);
        view.setUint16(geoKeyOffset + 6, 0, true);

        const blob = new Blob([buffer], { type: 'image/tiff' });
        const link = document.createElement('a');
        link.download = 'generated_terrain.tif';
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    // --- Physics & Util ---

    function getTerrainHeight(x, z) {
        if (!processedHeightData) return 0;
        
        const halfW = currentWorldWidth / 2;
        const halfD = currentWorldDepth / 2;
        
        let u = (x + halfW) / currentWorldWidth;
        let v = (z + halfD) / currentWorldDepth;

        if (u < 0 || u >= 1 || v < 0 || v >= 1) return -1000;

        const resX = window.terrainW;
        const resY = window.terrainH;

        const gridX = u * (resX - 1);
        const gridZ = v * (resY - 1);

        const col0 = Math.floor(gridX);
        const row0 = Math.floor(gridZ);
        const col1 = Math.min(col0 + 1, resX - 1);
        const row1 = Math.min(row0 + 1, resY - 1);

        const fracX = gridX - col0;
        const fracZ = gridZ - row0;

        const h00 = processedHeightData[row0 * resX + col0];
        const h10 = processedHeightData[row0 * resX + col1];
        const h01 = processedHeightData[row1 * resX + col0];
        const h11 = processedHeightData[row1 * resX + col1];

        const h0 = h00 * (1 - fracX) + h10 * fracX; 
        const h1 = h01 * (1 - fracX) + h11 * fracX; 
        
        const height = h0 * (1 - fracZ) + h1 * fracZ;

        return height * HEIGHT_SCALE;
    }

    function smoothHeights(heights, width, height) {
        const newHeights = new Float32Array(heights.length);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let sum = 0;
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            sum += heights[ny * width + nx];
                            count++;
                        }
                    }
                }
                newHeights[y * width + x] = sum / count;
            }
        }
        return newHeights;
    }

    // --- Copied Helpers ---
    function onKey(event, isDown) {
        switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveForward = isDown; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = isDown; break;
            case 'ArrowDown': case 'KeyS': moveBackward = isDown; break;
            case 'ArrowRight': case 'KeyD': moveRight = isDown; break;
            case 'Space': if (canJump && isDown) { velocity.y += 350; canJump = false; } break;
            case 'ShiftLeft': isRunning = isDown; break;
        }
    }

    function fbm(x, y, z, generator) {
        let value = 0, amplitude = 1, frequency = 1, maxValue = 0; 
        for(let i=0; i<6; i++) {
            let n = generator.noise(x * frequency, y * frequency, z);
            value += n * amplitude;
            maxValue += amplitude;
            amplitude *= 0.5;
            frequency *= 2.0;
        }
        return value / maxValue; 
    }

    function generateAdvancedRandomTerrain() {
        isRandomGen = true;
        document.getElementById('btn-export-dem').style.display = 'inline-block';
        currentAspect = 1.0;
        demMetaData.hasMetadata = false; demMetaData.min = 0; demMetaData.max = 800; 
        
        const width = CHUNK_RES;
        const height = CHUNK_RES;
        const size = width * height;
        const data = new Float32Array(size);
        const perlin = new ImprovedNoise();
        const z = Math.random() * 1000;
        let minH = Infinity, maxH = -Infinity;

        for (let i = 0; i < size; i++) {
            const x = i % width;
            const y = ~~(i / width);
            const nx = (x / width);
            const ny = (y / height);

            let base = 0; let amp = 1; let freq = 1.5;
            for(let k=0; k<2; k++) { base += perlin.noise(nx * freq, ny * freq, z) * amp; amp *= 0.5; freq *= 2; }
            base = Math.pow(base * 0.5 + 0.5, 1.5);

            let ridge = 0; amp = 1.2; freq = 3.5;
            for(let k=0; k<5; k++) {
                let n = perlin.noise(nx * freq, ny * freq, z + 50.5);
                n = 1.0 - Math.abs(n); n = n * n;
                ridge += n * amp; amp *= 0.5; freq *= 2.0;
            }
            let h = Math.pow(base * 0.5 + (ridge * base) * 0.5, 1.6);
            data[i] = h;
            if(h < minH) minH = h;
            if(h > maxH) maxH = h;
        }
        const range = maxH - minH;
        for(let i=0; i<size; i++) data[i] = (data[i] - minH) / range;

        // Minimap
        const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d'); const imgData = ctx.createImageData(width, height);
        for (let i = 0; i < size; i++) {
             const val = Math.floor(data[i] * 255); const idx = i * 4;
             imgData.data[idx] = val; imgData.data[idx+1] = val; imgData.data[idx+2] = val; imgData.data[idx+3] = 255;
        }
        ctx.putImageData(imgData, 0, 0);
        document.getElementById('minimap-img').src = canvas.toDataURL();
        document.getElementById('stat-display').innerText = `Res: ${width}x${height} | Ratio: 1.00`;

        rawHeightData = data;
        buildTerrain(data, width, height);
    }

    // Include existing file/image logic...
    async function handleFileUpload(event) {
        const file = event.target.files[0]; if (!file) return;
        const loader = document.getElementById('loading-indicator'); loader.style.display = 'block';
        const name = file.name.toLowerCase(); document.getElementById('minimap-title').innerText = file.name;
        isRandomGen = false; document.getElementById('btn-export-dem').style.display = 'none';

        try {
            if (name.endsWith('.tif') || name.endsWith('.tiff')) {
                const tiff = await fromBlob(file);
                const image = await tiff.getImage();
                activeGeoTiffImage = image; activeImageSource = null;
                const rawWidth = image.getWidth(); const rawHeight = image.getHeight();
                currentAspect = rawWidth / rawHeight;
                const fileDirectory = image.getFileDirectory();
                const modelPixelScale = fileDirectory.ModelPixelScale;
                demMetaData.rawWidth = rawWidth; demMetaData.rawHeight = rawHeight; demMetaData.hasMetadata = true;
                if (modelPixelScale && modelPixelScale.length >= 1) demMetaData.pixelScaleX = modelPixelScale[0];
                else demMetaData.pixelScaleX = 30; 
                await reloadGeoTiff(image);
            } else {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        activeImageSource = img; activeGeoTiffImage = null;
                        currentAspect = img.width / img.height;
                        demMetaData.rawWidth = img.width; demMetaData.rawHeight = img.height;
                        demMetaData.hasMetadata = false; demMetaData.min = 0; demMetaData.max = 255; 
                        document.getElementById('minimap-img').src = img.src; 
                        generateFromImage(img); loader.style.display = 'none';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        } catch (err) { console.error(err); alert("Error: " + err.message); loader.style.display = 'none'; }
    }

    async function reloadGeoTiff(image) {
        const loader = document.getElementById('loading-indicator'); const msg = document.getElementById('loading-msg');
        let targetRes = CHUNK_RES;
        let readW, readH;
        if (currentAspect >= 1) { readW = targetRes; readH = Math.round(targetRes / currentAspect); } 
        else { readH = targetRes; readW = Math.round(targetRes * currentAspect); }

        let rasters = null; let success = false;
        let attemptW = readW; let attemptH = readH;
        const maxAttempts = 6;

        for(let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                if(attempt > 1) msg.innerText = `Retrying at ${attemptW}x${attemptH}...`;
                if(attemptW < 2 || attemptH < 2) break; 
                rasters = await image.readRasters({ width: attemptW, height: attemptH });
                if(rasters && rasters[0]) {
                    success = true; CHUNK_RES = Math.max(attemptW, attemptH);
                    readW = attemptW; readH = attemptH; break; 
                }
            } catch (e) { attemptW = Math.floor(attemptW / 2); attemptH = Math.floor(attemptH / 2); }
        }

        if (!success || !rasters || !rasters[0]) { loader.style.display = 'none'; alert("Memory allocation failed."); return; }
        generateGeoTiffPreview({ data: rasters[0], width: readW, height: readH });
        processGeoTiffData({ data: rasters[0], width: readW, height: readH });
        document.getElementById('stat-display').innerText = `Res: ${readW}x${readH} | Ratio: ${currentAspect.toFixed(2)}`;
    }

    function processGeoTiffData(tiffData) {
        const { data, width, height } = tiffData;
        const loader = document.getElementById('loading-indicator');
        const size = width * height;
        const sampledHeights = new Float32Array(size);
        let min = Infinity, max = -Infinity;
        for (let i = 0; i < size; i++) {
            const val = data[i];
            if (val > -10000 && val < 10000) { if (val < min) min = val; if (val > max) max = val; }
        }
        if (min === Infinity) { min = 0; max = 1; } 
        const range = max - min || 1;
        demMetaData.min = min; demMetaData.max = max;
        for (let i = 0; i < size; i++) {
            let val = data[i]; if (val < -10000 || val > 10000) val = min;
            sampledHeights[i] = (val - min) / range;
        }
        rawHeightData = sampledHeights;
        buildTerrain(sampledHeights, width, height);
        loader.style.display = 'none';
    }

    function generateFromImage(image) {
        const loader = document.getElementById('loading-indicator');
        let w, h;
        if (currentAspect >= 1) { w = CHUNK_RES; h = Math.round(CHUNK_RES / currentAspect); } 
        else { h = CHUNK_RES; w = Math.round(CHUNK_RES * currentAspect); }
        document.getElementById('stat-display').innerText = `Res: ${w}x${h} | Ratio: ${currentAspect.toFixed(2)}`;
        const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d'); ctx.drawImage(image, 0, 0, w, h); 
        const imgData = ctx.getImageData(0, 0, w, h); const data = imgData.data;
        const heights = new Float32Array(w * h);
        for (let i = 0, j = 0; i < heights.length; i++, j += 4) { heights[i] = data[j] / 255; }
        rawHeightData = heights;
        buildTerrain(heights, w, h);
        loader.style.display = 'none';
    }

    function triggerReload() {
        const loader = document.getElementById('loading-indicator');
        loader.style.display = 'block'; document.getElementById('loading-msg').innerText = "Re-sampling data...";
        setTimeout(() => {
            if(activeGeoTiffImage) reloadGeoTiff(activeGeoTiffImage);
            else if(activeImageSource) generateFromImage(activeImageSource);
            else generateAdvancedRandomTerrain();
            loader.style.display = 'none';
        }, 100);
    }

    function generateGeoTiffPreview(tiffData) {
        const { data, width, height } = tiffData;
        const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d'); const imgData = ctx.createImageData(width, height);
        let min = Infinity, max = -Infinity;
        for (let i = 0; i < data.length; i += 20) {
             const val = data[i];
             if (val > -10000 && val < 10000) { if(val < min) min = val; if(val > max) max = val; }
        }
        const range = max - min || 1;
        for (let i = 0; i < data.length; i++) {
            let val = data[i]; if (val < -10000) val = min; 
            const norm = ((val - min) / range) * 255; const index = i * 4;
            imgData.data[index] = norm; imgData.data[index+1] = norm; imgData.data[index+2] = norm; imgData.data[index+3] = 255;    
        }
        ctx.putImageData(imgData, 0, 0);
        document.getElementById('minimap-img').src = canvas.toDataURL();
    }

    function setupTouchControls() {
        const joystickZone = document.getElementById('joystick-zone');
        const knob = document.getElementById('joystick-knob');
        const jumpBtn = document.getElementById('jump-btn');
        let touchId = null; let startX = 0, startY = 0;

        joystickZone.addEventListener('touchstart', (e) => { e.preventDefault(); const touch = e.changedTouches[0]; touchId = touch.identifier; startX = touch.clientX; startY = touch.clientY; }, {passive: false});
        joystickZone.addEventListener('touchmove', (e) => { e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === touchId) { const touch = e.changedTouches[i]; let dx = touch.clientX - startX; let dy = touch.clientY - startY; const distance = Math.sqrt(dx*dx + dy*dy); const maxDist = 35; if(distance > maxDist) { dx = (dx/distance) * maxDist; dy = (dy/distance) * maxDist; } knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`; moveForward = dy < -10; moveBackward = dy > 10; moveLeft = dx < -10; moveRight = dx > 10; } } }, {passive: false});
        const resetJoystick = () => { touchId = null; knob.style.transform = `translate(-50%, -50%)`; moveForward = moveBackward = moveLeft = moveRight = false; };
        joystickZone.addEventListener('touchend', resetJoystick); joystickZone.addEventListener('touchcancel', resetJoystick);
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if(canJump) { velocity.y += 350; canJump = false; } jumpBtn.style.background = "rgba(74, 144, 226, 0.8)"; }, {passive: false});
        jumpBtn.addEventListener('touchend', () => { jumpBtn.style.background = "rgba(74, 144, 226, 0.4)"; });
        document.addEventListener('touchstart', (e) => { if(e.target.closest('#joystick-zone') || e.target.closest('#ui-layer') || e.target.closest('#jump-btn') || e.target.closest('#toggle-ui')) return; touchLookStartX = e.touches[0].clientX; touchLookStartY = e.touches[0].clientY; });
        document.addEventListener('touchmove', (e) => { if(e.target.closest('#joystick-zone') || e.target.closest('#ui-layer') || e.target.closest('#jump-btn')) return; const x = e.touches[0].clientX; const y = e.touches[0].clientY; const sensitivity = 0.005; const deltaX = x - touchLookStartX; const deltaY = y - touchLookStartY; controls.getObject().rotation.y -= deltaX * sensitivity; cameraPitch -= deltaY * sensitivity; cameraPitch = Math.max( - Math.PI / 2, Math.min( Math.PI / 2, cameraPitch ) ); camera.rotation.x = cameraPitch; touchLookStartX = x; touchLookStartY = y; });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        let delta = (time - prevTime) / 1000;
        delta = Math.min(delta, 0.1); 
        
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 100.0 * delta; 

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize(); 

        const speed = isRunning ? 2000.0 : 800.0;
        if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        const playerPos = controls.getObject().position;
        const terrainH = getTerrainHeight(playerPos.x, playerPos.z);
        const eyeHeight = 15;

        if (playerPos.y < terrainH + eyeHeight) {
            velocity.y = Math.max(0, velocity.y);
            playerPos.y = terrainH + eyeHeight;
            canJump = true;
        }
        playerPos.y += velocity.y * delta;
        if (playerPos.y < -100) { playerPos.set(0, HEIGHT_SCALE + 50, 0); velocity.set(0,0,0); }

        // Update Minimap and Elevation
        const marker = document.getElementById('minimap-marker');
        if (marker) {
            const u = (playerPos.x + currentWorldWidth/2) / currentWorldWidth;
            const v = (playerPos.z + currentWorldDepth/2) / currentWorldDepth;
            const left = Math.max(0, Math.min(100, u * 100));
            const top = Math.max(0, Math.min(100, v * 100));
            marker.style.left = left + '%';
            marker.style.top = top + '%';

            if (demMetaData.hasMetadata || rawHeightData) {
                const normalizedH = (Math.max(terrainH, 0)) / HEIGHT_SCALE;
                const realH = normalizedH * (demMetaData.max - demMetaData.min) + demMetaData.min;
                document.getElementById('elevation-display').innerText = `Elev: ${Math.round(realH)} m`;
            }
        }

        prevTime = time;
        renderer.render(scene, camera);
    }
</script>
</body>
</html>